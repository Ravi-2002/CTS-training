/**
 * @jest-environment jsdom
 */
import React from "react";
import { render, screen, fireEvent, act } from "@testing-library/react";
import "@testing-library/jest-dom";
import ToNumberShareContainer from "./ToNumberShareContainer";

// ------------------ MOCKS ------------------

// mock redux
const mockDispatch = jest.fn();
let mockState;
jest.mock("react-redux", () => ({
  useDispatch: () => mockDispatch,
  useSelector: (sel) => sel(mockState),
}));

// mock react-router
const pushMock = jest.fn();
let mockId = "child-1";
jest.mock("react-router-dom", () => {
  const real = jest.requireActual("react-router-dom");
  return {
    ...real,
    useHistory: () => ({ push: pushMock }),
    useParams: () => ({ id: mockId ? encodeURIComponent(mockId) : "" }),
  };
});

// mock actions
jest.mock("../home/actions", () => ({
  setSelectedDeviceId: (id) => ({ type: "SET_ID", payload: id }),
  fetchDevices: () => ({ type: "FETCH" }),
  saveMoveLine: (req) => ({ type: "MOVE", payload: req }),
  sendSMS: (req) => ({ type: "SMS", payload: req }),
}));

// mock modal text
jest.mock("../CommonModal/modalText.json", () => ({
  moveErrorMessage: { id: "ERRID", title: "Error Title" },
}));

// mock components
jest.mock("./ToNumberShare", () => (props) => (
  <div data-testid="share">
    <button
      data-testid="select"
      onClick={() => props.selectedDevice("parent-123")}
    >
      select
    </button>
    <div>{JSON.stringify(props.cqData)}</div>
  </div>
));

jest.mock("../CommonModal/CommonModal", () => (props) => (
  <div
    data-testid="modal"
    data-open={props.open ? "true" : "false"}
    onClick={props.close}
  >
    modal-{props.message?.id}
  </div>
));

jest.mock("../../../shared/components/Loader/CustomLoader", () => () => (
  <div data-testid="loader">loading</div>
));

// mock hook
const hookMock = jest.fn();
jest.mock("../shared/useMoveLineHandler", () => (args) => hookMock(args));

// mock utils
const moveLineMock = jest.fn(
  (child, parent, parentId, setIsLoading, setReq, dispatch, actions, form) => {
    setIsLoading(true);
    setReq(true);
    dispatch(actions.saveMoveLine({ moved: true }));
    setIsLoading(false);
  }
);
const getDeviceDetailsMock = jest.fn((arr, pid, parentRef) => {
  parentRef.current = { id: pid.current, mdn: "111" };
});
const getChildDetailsMock = jest.fn((arr, cid, childRef) => {
  childRef.current = { id: cid.current, mdn: "222" };
});
const onConfirmationMock = jest.fn();

jest.mock("./numbershareUtils", () => ({
  moveLine: (...a) => moveLineMock(...a),
  createSubmitForm: jest.fn(),
  getDeviceDetails: (...a) => getDeviceDetailsMock(...a),
  getChildDetails: (...a) => getChildDetailsMock(...a),
  onConfirmation: (...a) => onConfirmationMock(...a),
}));

// ------------------ TESTS ------------------

beforeEach(() => {
  jest.clearAllMocks();
  mockId = "child-1";
  mockState = {
    devices: {
      isFetching: false,
      deviceDetails: [{ primaryInfo: { id: "parent-123" } }],
      cqData: { info: "CQ" },
      connectableDevices: [{ id: "child-1" }],
      errorMessage: null,
      moveLineResponse: {},
    },
  };
});

test("redirects when no id", () => {
  mockId = "";
  const oldHref = window.location.href;
  delete window.location;
  window.location = { href: "init" };

  render(<ToNumberShareContainer />);
  expect(window.location.href).toBe("/");

  window.location.href = oldHref;
});

test("dispatches on mount and shows loader when fetching", () => {
  mockState.devices.isFetching = true;
  render(<ToNumberShareContainer />);

  expect(mockDispatch).toHaveBeenCalledWith({ type: "SET_ID", payload: "child-1" });
  expect(mockDispatch).toHaveBeenCalledWith({ type: "FETCH" });
  expect(screen.getByTestId("loader")).toBeInTheDocument();
  expect(screen.queryByTestId("share")).not.toBeInTheDocument();
});

test("renders ToNumberShare when not fetching", () => {
  render(<ToNumberShareContainer />);
  expect(screen.getByTestId("share")).toBeInTheDocument();

  // hook called with correct object
  const args = hookMock.mock.calls[0][0];
  expect(args).toHaveProperty("moveLineRequested");
  expect(args).toHaveProperty("onConfirmation");

  // onConfirmation wrapper works
  act(() => {
    args.onConfirmation();
  });
  expect(onConfirmationMock).toHaveBeenCalled();
});

test("selecting device triggers utils and dispatch", () => {
  render(<ToNumberShareContainer />);
  fireEvent.click(screen.getByTestId("select"));

  expect(getDeviceDetailsMock).toHaveBeenCalled();
  expect(getChildDetailsMock).toHaveBeenCalled();
  expect(moveLineMock).toHaveBeenCalled();
  expect(mockDispatch).toHaveBeenCalledWith({ type: "MOVE", payload: { moved: true } });
});

test("modal can be opened and closed", () => {
  render(<ToNumberShareContainer />);
  const args = hookMock.mock.calls[0][0];

  // open modal
  act(() => {
    args.setShowModal(true);
  });
  expect(screen.getByTestId("modal")).toHaveAttribute("data-open", "true");

  // close modal via CommonModal's close prop
  act(() => {
    screen.getByTestId("modal").click();
  });
  expect(screen.getByTestId("modal")).toHaveAttribute("data-open", "false");
});

test("isInitTagging branch only runs once", () => {
  render(<ToNumberShareContainer />);
  expect(hookMock).toHaveBeenCalledTimes(1);

  // re-render: second call, but setIsInitTagging shouldn't re-trigger
  render(<ToNumberShareContainer />);
  expect(hookMock).toHaveBeenCalledTimes(2);
});