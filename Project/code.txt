import React, { Component } from 'react';
import styled from 'styled-components';
import { DragDropContext, Droppable, Draggable} from 'react-beautiful-dnd';
import { Notification } from '@vds/notifications';
import CommonModal from '../../../CommonModal/CommonModal';
import * as modalData from '../../../CommonModal/modalText.json';
import * as actions from '../../actions';
import * as saveMoveLineActions from '../../actions/saveMoveLine'
import ParentDevices from './ParentDevices';
import CustomLoader from '../../../../../shared/components/Loader/CustomLoader';
import HorizontalBar from '../../../HorizontalBar/HorizontalBar';
import common from '../../../../../shared/utilities/util';
import { TextLink } from '@vds/buttons';
import { Body } from '@vds/typography';
import { connect, useDispatch, useSelector } from 'react-redux';
import axios from 'axios';
import apiUrl from '../../../../../shared/utilities/apiUrl';



const Container = styled.div`
  display: flex;
  flex-direction: column;
  width: 100%;
`;

const StyledDeviceContainer = styled.div`
  :focus {
    outline: none;
  }
`;

const StyledNotificationBanner = styled.div``;

const StyledSymbol = styled.span`
padding-left: 0px;
`;

const StyledEscText = styled.span`
padding-left: 10px;
`;

const lightHorizontalBar = styled(HorizontalBar)`
color: red;
`;


const Devices = (props) => {
  const {
    cDeviceDetails: lineDetails,
    deviceContainerInFocus,
    deviceDetails,
    devicesSection,
    moveLineRequest,
    setSpkDragError,
  } = props;
  const [devicesLabels, setDevicesLabels] = React.useState({
    activationLabel: 'activationText',
    addressText: 'addressText',
    ariaConvertToNumbershareLabel: 'ariaConvertToNumbershareLabel',
    ariaConvertToStandaloneLabel: 'ariaConvertToStandaloneLabel',
    ariaNumSharedWithLabel: 'ariaNumSharedWithLabel',
    batchLink: 'batchLink',
    convertToNumberShareLabel: 'convertToNumShareLink',
    convertToStandaloneLabel: 'convertToStandaloneLink',
    editEmergencyAddressAriaLabelAmazon: 'addressAmazonLabel',
    editEmergencyAddressAriaLabelGoogle: 'addressGoogleLabel',
    editLinkLabel: 'editLink',
    lastInteractionLabel: 'interactionText',
    locatedAtLabel: 'locatedText',
    numberSharedWithLabel: 'numSharedWithLabel',
    removeLocLabel: 'removeLocLink',
    removeSpeakerAriaLabelAmazon: 'locationAmazonLabel',
    removeSpeakerAriaLabelGoogle: 'locationGoogleLabel',
    removeSpeakerLabel: 'removeSpeakerLink',
  });
  const [errorMessage, setErrorMessage] = React.useState('');
  const [isLoading, setIsLoading] = React.useState(false);
  const [modalId, setModalId] = React.useState('');
  const [modalMessage, setModalMessage] = React.useState('');
  const [showModal, setShowModal] = React.useState(false);
  const [validateMoveRequest, setValidateMoveRequest] = React.useState({});
  const [speakerDragError, setSpeakerDragError] = React.useState(false);
  const dispatch = useDispatch();
  const closeModal = () => {
    setShowModal(false);
    if (window.vztag && window.vztag.api) {
      window.vztag.api.dispatch('closeView', { name: modalId + '_modal', selector: '#' + modalId + '_overlay' });
    }
  }

  const openModal = () => {
    setShowModal(true);
    setTimeout(() => {
      if (window.vztag && window.vztag.api) {
        window.vztag.api.dispatch('openView', { name: modalId + '_modal', selector: '#' + modalId + '_overlay' });
      }
    }, 1000);
  }

  const onClickHandler = () => {
    closeModal();
    moveLineRequest(validateMoveRequest);
  }

  const changeParent = async (changeparentparams) => {
    try {
      setIsLoading(true);
      // const reqObj = changeparentparams ;
      // Transform the keys in changeparentparams and assign to reqObj for req of movecheck call..
      const reqObj = {
        trunkMdn: changeparentparams.moveFrom,
        branchMtn: changeparentparams.secondaryDevice,
        newtrunkMdn: changeparentparams.moveTo,
        numberShareIndicator: "M"
      };
       
      // MAKE IT POST\
      //let res = actions.saveMoveLine();  // prviously thy givnsavmovlin but logically it call mov check first whil drag and drop..  
      let res = await axios.post( apiUrl().retrieveNumberShareDetails,reqObj,
      {
        headers: {
          pageName: 'numberShare',
          flowName: 'numberShare'
        }
      });

      // --> Below code is for local run
      // let res;
      // if (window.location.hostname.indexOf('localhost') > -1) {
      //   res = await axios.get(
      //     apiUrl().lineSharingMoveCheckApiUrl,
      //     { params: reqObj }
      //   );
      // } else {
      //   res = await axios.post(
      //     reactGlobals.retrieveNumberShareDetails,
      //     reqObj
      //   );
      // }
      const { data } = res;
      setIsLoading(false);

      if (data?.body?.valid) {  //prev mock--data.isValid, ..inbtwn changed to response code 00 (data.responseInfo.responseCode=="00")
        // CONFIRMATION MODAL
        setModalMessage(modalData.switchMessage);
        setModalId(modalData.switchMessage.id);
        setErrorMessage('');
        openModal();
      } else {
        // SHOW ERROR
        setModalMessage(modalData.errorMessage);
        setModalId('line_move_error');
        setErrorMessage(data.body.message);
        openModal();
      }
    } catch (e) {
      setIsLoading(false);
      closeModal();
      setModalMessage(modalData.errorMessage);
      setModalId('line_move_error');
      setErrorMessage('Please try again later.');
      openModal();
    }
  }

  const onDragStart = (start, provided) => {
    const lineDetails = props.cDeviceDetails;
    const sIndex = start.source.index;
    const oldLinkedMdn = lineDetails[sIndex]?.linkedMdn && lineDetails[sIndex]?.linkedMdn || lineDetails[sIndex]?.formattedMdn;
    provided.announce(
      `You have selected an item of ${oldLinkedMdn}. Use up and down arrow keys to move position. Space bar to drop and escape to cancel.`
    );
  }

  const onDragUpdate = (update, provided) => {
    let dIndex = update?.destination && update?.destination.index;
    const sIndex = update?.source.index;
    const oldLinkedMdn = lineDetails[sIndex]?.linkedMdn;

    if (dIndex < 1) {
      dIndex = 1;
    } else if (dIndex < sIndex) {
      dIndex -= 1;
    }

    const newLinkedMdn = lineDetails[dIndex].type !== 'childline' && lineDetails[dIndex].formattedMdn || lineDetails[dIndex].linkedMdn;

    const message = update.destination && update.destination.index !== 0 && newLinkedMdn && oldLinkedMdn !== newLinkedMdn
      ? `You have moved the item to ${newLinkedMdn} mdn`
      : update.destination && update.destination.index !== 0 && newLinkedMdn && oldLinkedMdn === newLinkedMdn
        ? `You have moved the item to the same mdn ${newLinkedMdn} mdn`
        : update.destination.index === update.source.index ? `you moved to the same mdn ${oldLinedMdn}`
          : 'You are currently not over a droppable area';
    provided.announce(message);
  };
  /*istanbul ignore next*/
  const onDragEnd = (result, provided) => {
    let reqObj = {}; const newReqObj = {};
    const { destination, source, draggableId } = result;
    let dIndex = result.destination && result?.destination?.index;
    const sIndex = result?.source?.index;
    const oldLinkedMdn = lineDetails[sIndex].linkedMdn || lineDetails[sIndex].formattedMdn;
    const oldParentId = lineDetails[sIndex].parentId;

    if (dIndex < 1) {
      dIndex = 1;
    } else if (dIndex < sIndex) {
      dIndex -= 1;
    }
    const newLinkedMdn = lineDetails[dIndex].linkedMdn || lineDetails[dIndex].formattedMdn;
    const newParentId = lineDetails[dIndex].parentId || lineDetails[dIndex].id;
    const noParentId = lineDetails[dIndex].parentId;

    if (result.reason === 'CANCEL') {
      provided.announce(`Movement cancelled, item has returned to same position of mdn ${oldLinkedMdn}`);
      return;
    }

    if (!destination || destination.index === 0) {
      provided.announce(`Item has returned to same position of mdn ${oldLinkedMdn}`);
      return;
    }

    if (oldLinkedMdn === newLinkedMdn) {
      provided.announce(`Item has returned to same position of mdn ${oldLinkedMdn}`);
      return;
    }

    reqObj = {
      "moveFrom": oldParentId,
      "moveTo": newParentId,
      "secondaryDevice": draggableId.substr(3),
    };

    const message = result && result.source.index === result.destination.index && result.destination.index !== 0
      ? 'you dropped an item to the same position'
      : newLinkedMdn && lineDetails[sIndex].deviceType !== 'SPK'
        ? `you moved the item of ${oldLinkedMdn} to ${newLinkedMdn}`
        : 'item moved back to same position';
    provided.announce(message);

    deviceDetails && deviceDetails.map((devices) => {
      devices.connectedDevices && devices.connectedDevices.map((childDevices) => {
        if ((childDevices.deviceId === reqObj.secondaryDevice) || (childDevices.id === reqObj.secondaryDevice)) {
          if (childDevices.deviceType === 'SPK') {
            setSpeakerDragError(true);
          } else {
            setSpeakerDragError(false);
          }
        }
      });
    });
    // changeParent(reqObj);    //To show the modal for confirmation from local
    setTimeout(()=>{
      if(!speakerDragError) {
        setValidateMoveRequest(reqObj);
        changeParent(reqObj);
      } else {
        setSpkDragError(true);
      }
    },100)
  }

  const onAllEventClickHandler = () => {
    //closeModal();
    // openModal();
    changeParent();
    onClickHandler();
    onDragStart();
    //onDragUpdate({},{});
    //onDragEnd({},{});    
  }
  React.useEffect(() => {
    const deviceContainerElem = document.getElementById('deviceContainer');
    if (deviceContainerElem) {
      deviceContainerElem.setAttribute('tabIndex', '0');
    }
  }, []);

  React.useEffect(() => {
    let labelKeys = {};
    for (const [key, value] of Object.entries(devicesLabels)) {
      const label = common.getItemValue(devicesSection?.contents[0]?.items, value) ? common.getItemValue(devicesSection?.contents[0]?.items, value) : value;
      labelKeys[key] = label;
    }
    setDevicesLabels(labelKeys);
  }, [devicesSection]);


  return <StyledDeviceContainer
    data-testid="DevicesTestId"
    onFocus={deviceContainerInFocus}
    id='deviceContainer'
  >
    {isLoading && <CustomLoader />}

    <TextLink data-testid="EventCallTestId" onClick={(e) => onAllEventClickHandler()}></TextLink>
    <DragDropContext onDragEnd={onDragEnd} onDragStart={onDragStart} onDragUpdate={onDragUpdate}>
      <Droppable droppableId="root">
        {(provided) => (
          <Container
            {...provided.droppableProps}
            ref={provided.innerRef}
          >
            {lineDetails?.length > 0 && lineDetails.map((device, index) => (
              <React.Fragment>
                {device.type === 'parentline' && index > 0 && <HorizontalBar color="RGB(217,217,217)" width="1px 0 0 0" />}
                {device.isSpeakerWearable && device.isSpeakerWearable === true
                  && (
                    <ParentDevices
                      key={index}
                      index={index}
                      lineDetails={device}
                      allLineDetails={lineDetails}
                      deviceDetails={deviceDetails}
                      labels={devicesLabels}
                    />
                  )
                }
              </React.Fragment>
            ))}
            {provided.placeholder}
          </Container>
        )}
      </Droppable>
    </DragDropContext>
    <CommonModal
      modalId={modalId}
      close={closeModal}
      open={showModal}
      okClick={onClickHandler}
      onHide={closeModal}
      message={modalMessage}
      errorMessage={errorMessage}
    />
  </StyledDeviceContainer>
};


export default Devices;




