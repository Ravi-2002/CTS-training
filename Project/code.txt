import React from 'react';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureMockStore from 'redux-mock-store';
import BlockServices from './blockservices';
import * as actions from '../../actions/fetchServices';

// Mock Store and Actions
const mockStore = configureMockStore();
const mockActions = {
  getServices: jest.fn(),
  postServices: jest.fn(() => Promise.resolve()),
};

// Helper function to render the component with store
const renderComponent = (store) => {
  render(
    <Provider store={store}>
      <BlockServices actions={mockActions} />
    </Provider>
  );
};

describe('BlockServices Component', () => {
  let store;

  beforeEach(() => {
    // Initial mock state based on your provided JSON structure
    store = mockStore({
      Detail: {
        serviceCalls: {
          services: {
            "Emails & domains": { 
              isExpand: false, 
              data: [
                { 
                  sfoCode: '123', 
                  serviceName: 'Service A', 
                  sfoEnabled: 'Y', 
                  shortDescription: 'Short A', 
                  longDescription: 'Long A' 
                }
              ] 
            },
          },
          serviceStatus: { responseInfo: { responseCode: '0' } },
          isFetching: false,
        },
      },
    });
    store.dispatch = jest.fn(); // Mock the dispatch function
  });

  it('renders the BlockServices component correctly', () => {
    renderComponent(store);

    // Check if the block services title is present
    expect(screen.getByText(/Block services/i)).toBeInTheDocument();
  });

  it('calls getServices when the accordion is clicked', () => {
    renderComponent(store);

    const accordionButton = screen.getByRole('button', { name: /block services/i });
    fireEvent.click(accordionButton);

    expect(mockActions.getServices).toHaveBeenCalled();
  });

  it('expands sub-services when clicked', () => {
    renderComponent(store);

    const accordionButton = screen.getByRole('button', { name: /block services/i });
    fireEvent.click(accordionButton);

    const subAccordion = screen.getByRole('button', { name: /Emails & domains/i });
    fireEvent.click(subAccordion);

    // Check if sub-accordion is expanded
    expect(screen.getByText('Service A')).toBeInTheDocument();
  });

  it('toggles a service on and off', async () => {
    renderComponent(store);

    const accordionButton = screen.getByRole('button', { name: /block services/i });
    fireEvent.click(accordionButton);

    const toggleInput = screen.getByRole('checkbox');
    expect(toggleInput).toBeChecked(); // Initially 'On'

    await act(async () => {
      fireEvent.click(toggleInput);
    });

    expect(mockActions.postServices).toHaveBeenCalledWith({
      mdn: undefined, // Mock mdn value; pass encryptedMtn from props in real test
      sfoCode: '123',
      sfoEnabled: 'N', // Assume 'N' means the service is disabled
    });
  });

  it('shows a loader while fetching services', () => {
    // Update store to show fetching state
    store = mockStore({
      Detail: {
        serviceCalls: { isFetching: true },
      },
    });

    renderComponent(store);

    expect(screen.getByTestId('loader')).toBeInTheDocument();
  });

  it('renders an error message on failure', () => {
    // Mock a service error based on responseInfo errorCode
    store = mockStore({
      Detail: {
        serviceCalls: {
          serviceFail: true,
          failServices: { errorMessage: 'Something went wrong' },
        },
      },
    });

    renderComponent(store);

    expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument();
  });

  it('renders a success message on service toggle', () => {
    // Mock success flag based on responseInfo
    store = mockStore({
      Detail: {
        serviceCalls: {
          confirmServiceFlag: true,
          confirmServices: { successMsg: 'Service updated successfully' },
        },
      },
    });

    renderComponent(store);

    expect(screen.getByText(/Service updated successfully/i)).toBeInTheDocument();
  });

  it('does not call postServices if the service is already in the desired state', async () => {
    renderComponent(store);

    const accordionButton = screen.getByRole('button', { name: /block services/i });
    fireEvent.click(accordionButton);

    const toggleInput = screen.getByRole('checkbox');
    // Simulate service is already turned off
    fireEvent.click(toggleInput);
    expect(mockActions.postServices).not.toHaveBeenCalled(); // No post request if no change
  });
});