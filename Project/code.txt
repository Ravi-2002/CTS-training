handleCallsMessages = (e) => {
    e.preventDefault();
    this.props.selectAccordian('CM');

    if (!this.state.open) { // Only fetch when opening
        let payload = { mtn: this.props.selectedDevice?.encryptedMtn };
        this.props.getCallsMessages(payload).then(() => {
            this.setState({
                blockedList: this.props.blockedNumbers || [],
                expiredList: this.props.expiredNumbers || [],
                remainingBlockCount: this.props.callsMessagesData?.remainingBlockCount,
                addedBlockCount: this.props.callsMessagesData?.addedBlockCount
            }, () => {
                this.setState({ open: true }); // ✅ Open only after data is set
            });
        });
    } else {
        this.setState({ open: false });
    }
};

// ✅ Block Again with Proper State Update
handleBlockAgain = (e, number) => {
    e.preventDefault();
    if (reactGlobals.isCsr) return;

    let payload = {
        mtn: this.props.selectedDevice?.encryptedMtn,
        blockNumber: number.phoneNumber,
        oldPhoneNumber: number.oldPhoneNumber,
        expiredPhoneNumber: number.phoneNumber,
        blockedNumbers: [],
        memo: number.memo,
        applyAll: false,
        onlyMemo: false
    };

    this.setState({ isLoading: true });

    this.props.postBlockAgain(payload).then(() => {
        let elmnt = document.getElementById("myalert");
        if (elmnt != null) window.scrollTo(0, elmnt.offsetTop);

        if (parseInt(this.props.blockAgainResponse?.statusCode) === 0) {
            this.setState((prevState) => ({
                blockAgainSuccess: true,
                powerCycle: this.props.blockAgainResponse?.powerCycle,
                trackingId: "CallsMessagesSuccessNotification",
                errorMsg: null,
                deleteSuccess: null,
                editAllSuccess: null,
                editSuccess: null,
                addSuccess: null,
                failSuccess: null,
                blockedList: [...this.props.blockAgainResponse.blockedPhoneNumbers],  // ✅ Updated immediately
                expiredList: [...this.props.blockAgainResponse.expiredBlockedPhoneNumbers],
                remainingBlockCount: this.props.blockAgainResponse.remainingBlockCount, // ✅ Fixed count update
                isLoading: false
            }));
        } else {
            this.setState({
                blockAgainSuccess: false,
                isLoading: false,
                trackingId: "CallsMessagesFailureNotification"
            });
        }
    });
};

// ✅ Unblock (Delete) Number with Correct State Handling
deleteNumber = (e, number) => {
    e.preventDefault();
    if (reactGlobals.isCsr) return;

    let payload = {
        mtn: this.props.selectedDevice?.encryptedMtn,
        blockNumber: number.phoneNumber,
        oldPhoneNumber: number.phoneNumber,
        expiredPhoneNumber: "",
        blockedNumbers: [],
        memo: number.memo,
        applyAll: false,
        onlyMemo: false
    };

    this.setState({ isLoading: true });

    this.props.postDeleteBlockCallMsg(payload).then(() => {
        let elmnt = document.getElementById("myalert");
        if (elmnt != null) window.scrollTo(0, elmnt.offsetTop);

        if (this.props.deleteBlockCallMsgRes?.statusCode === "00") {
            this.setState({
                deleteSuccess: true,
                trackingId: "CallsMessagesSuccessNotification",
                blockedList: [...this.props.deleteBlockCallMsgRes.blockedPhoneNumbers],  // ✅ Update blocked list
                expiredList: [...this.props.deleteBlockCallMsgRes.expiredBlockedPhoneNumbers],
                remainingBlockCount: this.props.deleteBlockCallMsgRes.remainingBlockCount, // ✅ Update count
                isLoading: false
            });
        } else {
            this.setState({
                deleteSuccess: false,
                isLoading: false,
                trackingId: "CallsMessagesFailureNotification"
            });
        }
    });
};

// ✅ Ensure State Syncs with Redux Props
componentDidUpdate(prevProps) {
    if (prevProps.blockedNumbers !== this.props.blockedNumbers) {
        this.setState({ blockedList: this.props.blockedNumbers });
    }
    if (prevProps.remainingBlockCount !== this.props.remainingBlockCount) {
        this.setState({ remainingBlockCount: this.props.remainingBlockCount });
    }
}

// ✅ Display Remaining Block Count in UI
render() {
    return (
        <div>
            <button onClick={this.handleCallsMessages}>Toggle Dropdown</button>
            {this.state.open && (
                <div>
                    <p>Remaining Block Count: {this.state.remainingBlockCount}</p>  {/* ✅ UI updates immediately */}
                    {/* Render blocked numbers */}
                    {this.state.blockedList.map((number) => (
                        <div key={number.phoneNumber}>
                            <p>{number.phoneNumber}</p>
                            <button onClick={(e) => this.handleBlockAgain(e, number)}>Block Again</button>
                            <button onClick={(e) => this.deleteNumber(e, number)}>Unblock</button>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
}