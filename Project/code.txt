import React from 'react';
import { render, fireEvent, waitFor, screen } from '@testing-library/react';
import BlockServices from '../components/BlockServices'; // adjust path as needed
import configureStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import { Provider } from 'react-redux';
import * as actions from '../actions/fetchServices';
import * as common from '../../../../../shared/utilities/util';
import { MemoryRouter } from 'react-router-dom';

jest.mock('../actions/fetchServices', () => ({
  getServices: jest.fn(() => () => Promise.resolve()),
  postServices: jest.fn(() => Promise.resolve())
}));

jest.mock('../../../../../shared/utilities/util', () => ({
  getContentFromSection: jest.fn(() => ({
    sections: [{
      contents: [{
        items: [
          { key: 'dcbLink', value: 'DCB' },
          { key: 'videoLink', value: 'Video' },
          { key: 'faqsLink', value: 'FAQ' }
        ]
      }],
      actions: [
        { key: 'dcbLink', actionValue: 'https://dummy.dcb.com' },
        { key: 'videoLink', actionValue: 'https://dummy.video.com' },
        { key: 'faqsLink', actionValue: 'https://dummy.faq.com' }
      ]
    }]
  })),
  getItemValue: jest.fn((items, key) => {
    const item = items.find(i => i.key === key);
    return item ? item.value : null;
  }),
  getActionKey: jest.fn((items, key) => key),
  getActionByKey: jest.fn((actions, key) => actions.find(i => i.key === key)),
  getChannelId: jest.fn(() => 'web'),
}));

const middlewares = [thunk];
const mockStore = configureStore(middlewares);

const getMockedState = (overrides = {}) => ({
  Detail: {
    serviceCalls: {
      services: {
        'Category A': [
          {
            sfoCode: '123',
            sfoEnabled: 'Y',
            serviceName: 'Test Service',
            shortDescription: 'Short',
            longDescription: 'Long',
            showMore: false
          }
        ]
      },
      serviceStatus: {
        body: {
          pageAttributes: { enableManageBlockserviceLinkFlag: 'true' },
          sections: [{}],
        }
      },
      getServices: true,
      confirmServices: {
        responseInfo: {
          responseCode: '00'
        }
      },
      failServices: { errorMessage: 'Failed service' },
      serviceFail: false,
      confirmServiceFlag: true,
      serviceErrorFlag: false,
      servicesError: {
        internalErrors: [{ errorMessage: 'Service error' }]
      },
      isFetching: false,
      ...overrides
    }
  }
});

describe('BlockServices Component', () => {
  let store;

  beforeEach(() => {
    store = mockStore(getMockedState());
    jest.clearAllMocks();
  });

  const renderComponent = () =>
    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockServices selectedDevice={{ encryptedMtn: '12345' }} selectedAccordian="BS" selectAccordian={jest.fn()} />
        </MemoryRouter>
      </Provider>
    );

  test('renders the component with service list', async () => {
    renderComponent();

    expect(screen.getByTestId('BlockServicesTestId')).toBeInTheDocument();
    expect(screen.getByText('Block services')).toBeInTheDocument();
    expect(await screen.findByText('Category A')).toBeInTheDocument();
    expect(screen.getByText('Test Service')).toBeInTheDocument();
  });

  test('toggles service switch', async () => {
    const postSpy = jest.spyOn(actions, 'postServices').mockImplementation(() => Promise.resolve());

    renderComponent();

    const toggle = await screen.findByRole('checkbox');
    fireEvent.click(toggle);

    await waitFor(() => {
      expect(postSpy).toHaveBeenCalled();
    });
  });

  test('expands and collapses sub service accordion', async () => {
    renderComponent();

    const accordion = await screen.findByText('Category A');
    fireEvent.click(accordion);

    const toggle = await screen.findByRole('checkbox');
    expect(toggle).toBeInTheDocument();
  });

  test('displays loader when loading', () => {
    store = mockStore(getMockedState({ isFetching: true }));
    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockServices selectedDevice={{ encryptedMtn: '12345' }} selectedAccordian="BS" selectAccordian={jest.fn()} />
        </MemoryRouter>
      </Provider>
    );

    expect(screen.getAllByTestId('loader')).toHaveLength(2);
  });

  test('handles modal open', async () => {
    renderComponent();
    const viewMore = await screen.findByText('View More Details');
    fireEvent.click(viewMore);

    await waitFor(() => {
      expect(screen.getByText('Further details')).toBeInTheDocument();
    });
  });

  test('renders success alert', async () => {
    renderComponent();
    expect(await screen.findByTestId('BlockServicesTestId')).toBeInTheDocument();
    expect(screen.getByText(/successfully saved/i)).toBeInTheDocument();
  });

  test('handles external link click', async () => {
    renderComponent();
    const videoLink = await screen.findByText('Video');
    expect(videoLink).toBeInTheDocument();

    Object.defineProperty(window, 'location', {
      value: { href: '' },
      writable: true,
    });

    fireEvent.click(videoLink);
    expect(window.location.href).toContain('video.com');
  });

  test('renders fallback static links if flag is false', () => {
    store = mockStore(getMockedState({
      serviceStatus: {
        body: {
          pageAttributes: { enableManageBlockserviceLinkFlag: 'false' },
          sections: [{}],
        }
      }
    }));

    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockServices selectedDevice={{ encryptedMtn: '12345' }} selectedAccordian="BS" selectAccordian={jest.fn()} />
        </MemoryRouter>
      </Provider>
    );

    expect(screen.getByText('View Media & App Purchases')).toBeInTheDocument();
  });

  test('shows service failure alert', () => {
    store = mockStore(getMockedState({ serviceFail: true }));

    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockServices selectedDevice={{ encryptedMtn: '12345' }} selectedAccordian="BS" selectAccordian={jest.fn()} />
        </MemoryRouter>
      </Provider>
    );

    expect(screen.getByText('Failed service')).toBeInTheDocument();
  });
});