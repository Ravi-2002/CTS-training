import React from "react";
import { render, fireEvent, waitFor, screen } from "@testing-library/react";
import BlockCallsMessages from "../BlockCallsMessages";
import { Provider } from "react-redux";
import configureStore from "redux-mock-store";
import * as util from "../../../../../shared/utilities/util";
import * as actions from "../../actions/fetchCallsMessages";
import { MemoryRouter } from "react-router-dom";

jest.mock("../../../../../shared/utilities/util", () => ({
  getItemValue: jest.fn(),
  getChannelId: jest.fn(),
  getContentFromSection: jest.fn(),
  mtnFormat: jest.fn(),
}));

jest.mock("../../actions/fetchCallsMessages", () => ({
  postaddBlockCallMsg: jest.fn(),
  postDeleteBlockCallMsg: jest.fn(),
  posteditBlockCallMsg: jest.fn(),
  posteditAllBlockCallMsg: jest.fn(),
}));

const mockStore = configureStore([]);
const mockNavigate = jest.fn();

jest.mock("react-router-dom", () => ({
  ...jest.requireActual("react-router-dom"),
  useNavigate: () => mockNavigate,
}));

const defaultStore = {
  Detail: {
    callsMsgs: {
      blockedNumbers: [
        { id: 1, type: "call", number: "9876543210", memo: "Block 1" },
        { id: 2, type: "message", number: "9123456789", memo: "Block 2" },
      ],
      expiredNumbers: [
        { id: 3, type: "call", number: "9988776655", memo: "Expired Memo" },
      ],
      addBlockCallMsg: {
        successMsg: "Add success",
        hasSuccessMsg: true,
        hasFailureMsg: false,
      },
      deleteBlockCallMsg: {
        successMsg: "Delete success",
        hasSuccessMsg: true,
        hasFailureMsg: false,
      },
      editBlockCallMsg: {
        successMsg: "Edit success",
        hasSuccessMsg: true,
        hasFailureMsg: false,
      },
      editAllBlockCallMsg: {
        successMsg: "Edit all success",
        hasSuccessMsg: true,
        hasFailureMsg: false,
      },
      isFetching: false,
    },
  },
};

describe("BlockCallsMessages Component", () => {
  let store;

  beforeEach(() => {
    store = mockStore(defaultStore);

    util.getItemValue.mockReturnValue("Mock Item Value");
    util.getChannelId.mockReturnValue("Mock Channel ID");
    util.getContentFromSection.mockReturnValue({
      sections: [
        {
          items: [{ key: "label", value: "Blocked Number Label" }],
        },
      ],
    });
    util.mtnFormat.mockImplementation((num) => num);
  });

  test("renders correctly with blocked and expired numbers", () => {
    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockCallsMessages />
        </MemoryRouter>
      </Provider>
    );

    expect(screen.getByText("Blocked Number Label")).toBeInTheDocument();
    expect(screen.getByText("9876543210")).toBeInTheDocument();
    expect(screen.getByText("Block 1")).toBeInTheDocument();
    expect(screen.getByText("9988776655")).toBeInTheDocument();
    expect(screen.getByText("Expired Memo")).toBeInTheDocument();
  });

  test("handles add block number", async () => {
    actions.postaddBlockCallMsg.mockResolvedValue();

    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockCallsMessages />
        </MemoryRouter>
      </Provider>
    );

    fireEvent.click(screen.getByText("Add a number"));

    fireEvent.change(screen.getByPlaceholderText("Enter number"), {
      target: { value: "9876543210" },
    });
    fireEvent.change(screen.getByPlaceholderText("Memo"), {
      target: { value: "New Memo" },
    });

    fireEvent.click(screen.getByText("Block"));

    await waitFor(() =>
      expect(actions.postaddBlockCallMsg).toHaveBeenCalled()
    );
  });

  test("handles edit block number", async () => {
    actions.posteditBlockCallMsg.mockResolvedValue();

    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockCallsMessages />
        </MemoryRouter>
      </Provider>
    );

    fireEvent.click(screen.getAllByText("Edit")[0]);

    fireEvent.change(screen.getByPlaceholderText("Memo"), {
      target: { value: "Updated Memo" },
    });

    fireEvent.click(screen.getByText("Save"));

    await waitFor(() =>
      expect(actions.posteditBlockCallMsg).toHaveBeenCalled()
    );
  });

  test("handles delete block number", async () => {
    actions.postDeleteBlockCallMsg.mockResolvedValue();

    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockCallsMessages />
        </MemoryRouter>
      </Provider>
    );

    fireEvent.click(screen.getAllByText("Remove")[0]);

    await waitFor(() =>
      expect(actions.postDeleteBlockCallMsg).toHaveBeenCalled()
    );
  });

  test("handles edit all block numbers", async () => {
    actions.posteditAllBlockCallMsg.mockResolvedValue();

    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockCallsMessages />
        </MemoryRouter>
      </Provider>
    );

    fireEvent.click(screen.getByText("Edit All"));

    fireEvent.change(screen.getAllByPlaceholderText("Memo")[0], {
      target: { value: "Edited Memo All" },
    });

    fireEvent.click(screen.getByText("Save All"));

    await waitFor(() =>
      expect(actions.posteditAllBlockCallMsg).toHaveBeenCalled()
    );
  });

  test("displays loader when isFetching is true", () => {
    store = mockStore({
      Detail: {
        callsMsgs: {
          ...defaultStore.Detail.callsMsgs,
          isFetching: true,
        },
      },
    });

    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockCallsMessages />
        </MemoryRouter>
      </Provider>
    );

    expect(screen.getByTestId("loader")).toBeInTheDocument();
  });

  test("handles error in postaddBlockCallMsg", async () => {
    actions.postaddBlockCallMsg.mockRejectedValue(new Error("Add failed"));

    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockCallsMessages />
        </MemoryRouter>
      </Provider>
    );

    fireEvent.click(screen.getByText("Add a number"));

    fireEvent.change(screen.getByPlaceholderText("Enter number"), {
      target: { value: "9876543210" },
    });
    fireEvent.change(screen.getByPlaceholderText("Memo"), {
      target: { value: "Error Memo" },
    });

    fireEvent.click(screen.getByText("Block"));

    await waitFor(() =>
      expect(actions.postaddBlockCallMsg).toHaveBeenCalled()
    );
  });

  test("handles error in posteditBlockCallMsg", async () => {
    actions.posteditBlockCallMsg.mockRejectedValue(new Error("Edit failed"));

    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockCallsMessages />
        </MemoryRouter>
      </Provider>
    );

    fireEvent.click(screen.getAllByText("Edit")[0]);

    fireEvent.change(screen.getByPlaceholderText("Memo"), {
      target: { value: "Fail Memo" },
    });

    fireEvent.click(screen.getByText("Save"));

    await waitFor(() =>
      expect(actions.posteditBlockCallMsg).toHaveBeenCalled()
    );
  });

  test("handles error in postDeleteBlockCallMsg", async () => {
    actions.postDeleteBlockCallMsg.mockRejectedValue(new Error("Delete fail"));

    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockCallsMessages />
        </MemoryRouter>
      </Provider>
    );

    fireEvent.click(screen.getAllByText("Remove")[0]);

    await waitFor(() =>
      expect(actions.postDeleteBlockCallMsg).toHaveBeenCalled()
    );
  });

  test("handles error in posteditAllBlockCallMsg", async () => {
    actions.posteditAllBlockCallMsg.mockRejectedValue(new Error("Edit all failed"));

    render(
      <Provider store={store}>
        <MemoryRouter>
          <BlockCallsMessages />
        </MemoryRouter>
      </Provider>
    );

    fireEvent.click(screen.getByText("Edit All"));

    fireEvent.change(screen.getAllByPlaceholderText("Memo")[0], {
      target: { value: "Fail All Memo" },
    });

    fireEvent.click(screen.getByText("Save All"));

    await waitFor(() =>
      expect(actions.posteditAllBlockCallMsg).toHaveBeenCalled()
    );
  });
});