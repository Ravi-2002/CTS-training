import React from 'react';
import { shallow, mount } from 'enzyme';
import configureMockStore from 'redux-mock-store';
import { Provider } from 'react-redux';
import BlockServices from './BlockServices';
import * as actions from '../../actions/fetchServices';

// Mock the dependencies
jest.mock('../../../alert', () => 'Alert');
jest.mock('../blocksEmailDomains/BSEmailDomains', () => 'BSEmailDomains');
jest.mock('../../../../../shared/utilities/util', () => ({
  getContentFromSection: jest.fn(),
  getActionKey: jest.fn(),
  getActionByKey: jest.fn(),
  getItemValue: jest.fn(),
}));

const mockStore = configureMockStore([]);

describe('BlockServices Component', () => {
  let wrapper;
  let store;
  let mockActions;
  let defaultProps;
  let mockServices;

  beforeEach(() => {
    mockActions = {
      getServices: jest.fn(),
      postServices: jest.fn(),
    };

    mockServices = {
      'Additional Services': [
        {
          sfoCode: 'SFO001',
          serviceName: 'Service 1',
          sfoEnabled: 'Y',
          shortDescription: 'Short desc 1',
          longDescription: 'Long desc 1',
          showMore: false,
        },
      ],
      'Other Services': [
        {
          sfoCode: 'SFO002',
          serviceName: 'Service 2',
          sfoEnabled: 'N',
          shortDescription: 'Short desc 2',
          longDescription: 'Long desc 2',
          showMore: false,
        },
      ],
    };

    defaultProps = {
      selectedDevice: { encryptedMtn: '1234567890' },
      selectedAccordian: '',
      selectAccordian: jest.fn(),
      actions: mockActions,
      services: {},
      serviceStatus: {
        statusCode: '0',
        body: {
          sections: [
            {
              sections: [
                {
                  contents: [
                    {
                      items: [
                        { key: 'dcbLink', value: 'DCB Link Text' },
                        { key: 'videoLink', value: 'Video Link Text' },
                        { key: 'faqsLink', value: 'FAQs Link Text' },
                      ],
                    },
                  ],
                  actions: [
                    { key: 'dcbLink', actionValue: 'http://dcb.com' },
                    { key: 'videoLink', actionValue: 'http://video.com' },
                    { key: 'faqsLink', actionValue: 'http://faqs.com' },
                  ],
                },
              ],
            },
          ],
        },
      },
      getServices: false,
      failServices: null,
      serviceFail: false,
      confirmServices: null,
      serviceErrorFlag: false,
      confirmServiceFlag: false,
      servicesError: null,
      isFetching: false,
    };

    store = mockStore({
      Detail: {
        serviceCalls: {
          services: {},
          serviceStatus: null,
          getServices: false,
          failServices: null,
          serviceFail: false,
          confirmServices: null,
          serviceErrorFlag: false,
          confirmServiceFlag: false,
          servicesError: null,
          isFetching: false,
        },
      },
    });

    // Mock common utility functions
    const common = require('../../../../../shared/utilities/util').default;
    common.getContentFromSection.mockReturnValue({
      sections: [
        {
          contents: [
            {
              items: [
                { key: 'dcbLink', value: 'DCB Link Text' },
                { key: 'videoLink', value: 'Video Link Text' },
                { key: 'faqsLink', value: 'FAQs Link Text' },
              ],
            },
          ],
          actions: [
            { key: 'dcbLink', actionValue: 'http://dcb.com' },
            { key: 'videoLink', actionValue: 'http://video.com' },
            { key: 'faqsLink', actionValue: 'http://faqs.com' },
          ],
        },
      ],
    });
    common.getActionKey.mockReturnValue('dcbLink');
    common.getActionByKey.mockReturnValue({ actionValue: 'http://test.com' });
    common.getItemValue.mockReturnValue('Link Text');
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Component Initialization', () => {
    it('should render without crashing', () => {
      wrapper = shallow(<BlockServices.WrappedComponent {...defaultProps} />);
      expect(wrapper.exists()).toBe(true);
    });

    it('should initialize with correct default state', () => {
      wrapper = shallow(<BlockServices.WrappedComponent {...defaultProps} />);
      const state = wrapper.state();
      expect(state.open).toBe(false);
      expect(state.services).toEqual({});
      expect(state.openSub).toBe(false);
      expect(state.modalStatus).toBe(false);
      expect(state.status).toBe('');
      expect(state.longDesc).toBe('');
      expect(state.shortDesc).toBe('');
      expect(state.featureName).toBe('');
      expect(state.successMsg).toBe('');
    });
  });

  describe('handleServices', () => {
    it('should handle BS accordion click', () => {
      wrapper = shallow(<BlockServices.WrappedComponent {...defaultProps} />);
      const event = { preventDefault: jest.fn() };
      const scrollToSpy = jest.spyOn(window, 'scrollTo').mockImplementation();

      wrapper.instance().handleServices(event, 'BS');

      expect(event.preventDefault).toHaveBeenCalled();
      expect(scrollToSpy).toHaveBeenCalledWith(0, 0);
      expect(defaultProps.selectAccordian).toHaveBeenCalledWith('BS');
      expect(mockActions.getServices).toHaveBeenCalledWith('1234567890');

      scrollToSpy.mockRestore();
    });
  });

  describe('componentDidUpdate - Services Update', () => {
    it('should update state when services prop changes', () => {
      const props = { ...defaultProps };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const newProps = {
        ...props,
        services: mockServices,
      };

      wrapper.setProps(newProps);

      const state = wrapper.state();
      expect(Object.keys(state.services)).toContain('Emails & domains');
      expect(Object.keys(state.services)).toContain('Other Services');
      expect(Object.keys(state.services)).toContain('Additional Services');
    });

    it('should handle services without Additional Services', () => {
      const props = { ...defaultProps };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const servicesWithoutAdditional = {
        'Other Services': mockServices['Other Services'],
      };

      wrapper.setProps({ services: servicesWithoutAdditional });

      const state = wrapper.state();
      expect(Object.keys(state.services)).toContain('Emails & domains');
      expect(Object.keys(state.services)).toContain('Other Services');
      expect(Object.keys(state.services)).not.toContain('Additional Services');
    });

    it('should not update state if services prop is empty', () => {
      const props = { ...defaultProps };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const initialState = wrapper.state().services;
      wrapper.setProps({ services: {} });

      expect(wrapper.state().services).toEqual(initialState);
    });

    it('should not update state if services prop is null', () => {
      const props = { ...defaultProps };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const initialState = wrapper.state().services;
      wrapper.setProps({ services: null });

      expect(wrapper.state().services).toEqual(initialState);
    });
  });

  describe('componentDidUpdate - Confirm Services', () => {
    it('should handle successful service confirmation', () => {
      const props = {
        ...defaultProps,
        services: mockServices,
        getServices: true,
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      // First update to set services
      wrapper.setProps({ services: mockServices });

      // Set pending service
      wrapper.setState({
        pendingService: { service: 'Additional Services', i: 0 },
      });

      // Simulate confirmation
      const confirmServices = {
        responseInfo: { responseCode: '00' },
      };

      wrapper.setProps({ confirmServices });

      const state = wrapper.state();
      expect(state.services['Additional Services'].data[0].sfoEnabled).toBe('N');
      expect(state.updatedService).toBe('SFO001');
      expect(state.successMsg).toContain('Service 1');
      expect(state.pendingService).toBeNull();
    });

    it('should toggle sfoEnabled from N to Y', () => {
      const props = {
        ...defaultProps,
        services: mockServices,
        getServices: true,
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      wrapper.setState({
        pendingService: { service: 'Other Services', i: 0 },
      });

      const confirmServices = {
        responseInfo: { responseCode: '00' },
      };

      wrapper.setProps({ confirmServices });

      const state = wrapper.state();
      expect(state.services['Other Services'].data[0].sfoEnabled).toBe('Y');
    });

    it('should not update if responseCode is not 00', () => {
      const props = {
        ...defaultProps,
        services: mockServices,
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      const initialState = wrapper.state().services;

      wrapper.setState({
        pendingService: { service: 'Additional Services', i: 0 },
      });

      const confirmServices = {
        responseInfo: { responseCode: '99' },
      };

      wrapper.setProps({ confirmServices });

      expect(wrapper.state().services).toEqual(initialState);
    });

    it('should not update if no pending service', () => {
      const props = {
        ...defaultProps,
        services: mockServices,
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      const confirmServices = {
        responseInfo: { responseCode: '00' },
      };

      wrapper.setProps({ confirmServices });

      expect(wrapper.state().pendingService).toBeUndefined();
    });
  });

  describe('handleSubServices', () => {
    it('should expand selected service and collapse others', () => {
      const props = {
        ...defaultProps,
        services: mockServices,
        getServices: true,
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      const event = { preventDefault: jest.fn() };
      wrapper.instance().handleSubServices(event, 'Additional Services');

      expect(event.preventDefault).toHaveBeenCalled();
      expect(wrapper.state().services['Additional Services'].isExpand).toBe(true);
      expect(wrapper.state().services['Other Services'].isExpand).toBe(false);
    });

    it('should toggle expansion state of the same service', () => {
      const props = {
        ...defaultProps,
        services: mockServices,
        getServices: true,
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      const event = { preventDefault: jest.fn() };

      // First click - expand
      wrapper.instance().handleSubServices(event, 'Additional Services');
      expect(wrapper.state().services['Additional Services'].isExpand).toBe(true);

      // Second click - collapse
      wrapper.instance().handleSubServices(event, 'Additional Services');
      expect(wrapper.state().services['Additional Services'].isExpand).toBe(false);
    });
  });

  describe('toggleOn', () => {
    it('should call postServices with correct payload when toggling on', async () => {
      const props = {
        ...defaultProps,
        services: mockServices,
        getServices: true,
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      const event = { preventDefault: jest.fn() };

      await wrapper.instance().toggleOn(event, 'Additional Services', 0);

      expect(event.preventDefault).toHaveBeenCalled();
      expect(wrapper.state().successMsg).toBe('');
      expect(mockActions.postServices).toHaveBeenCalledWith({
        mdn: '1234567890',
        sfoCode: 'SFO001',
        sfoEnabled: 'N',
      });
      expect(wrapper.state().pendingService).toEqual({
        service: 'Additional Services',
        i: 0,
      });
    });

    it('should toggle from N to Y', async () => {
      const props = {
        ...defaultProps,
        services: mockServices,
        getServices: true,
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      const event = { preventDefault: jest.fn() };

      await wrapper.instance().toggleOn(event, 'Other Services', 0);

      expect(mockActions.postServices).toHaveBeenCalledWith({
        mdn: '1234567890',
        sfoCode: 'SFO002',
        sfoEnabled: 'Y',
      });
    });
  });

  describe('closePupup', () => {
    it('should set showPopup to false', () => {
      wrapper = shallow(<BlockServices.WrappedComponent {...defaultProps} />);

      wrapper.setState({ showPopup: true });

      const event = {};
      wrapper.instance().closePupup(event);

      expect(wrapper.state().showPopup).toBe(false);
    });
  });

  describe('Render - Alert Notifications', () => {
    it('should show failure notification when serviceFail is true', () => {
      const props = {
        ...defaultProps,
        serviceFail: true,
        failServices: { errorMessage: 'Service failed' },
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      expect(wrapper.find('Alert').prop('Message')).toBe('Service failed');
      expect(wrapper.find('Alert').prop('Type')).toBe(3);
    });

    it('should show default error message when failServices has no errorMessage', () => {
      const props = {
        ...defaultProps,
        serviceFail: true,
        failServices: {},
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      expect(wrapper.find('Alert').prop('Message')).toBe(
        'Something went wrong, Please try again later'
      );
    });

    it('should show error notification when serviceErrorFlag is true', () => {
      const props = {
        ...defaultProps,
        serviceErrorFlag: true,
        servicesError: {
          internalErrors: [{ errorMessage: 'Internal error' }],
        },
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      expect(wrapper.find('Alert').prop('Message')).toBe('Internal error');
      expect(wrapper.find('Alert').prop('Type')).toBe(3);
    });

    it('should show default error when servicesError has no message', () => {
      const props = {
        ...defaultProps,
        serviceErrorFlag: true,
        servicesError: null,
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      expect(wrapper.find('Alert').prop('Message')).toBe(
        'Something went wrong, Please try again later!'
      );
    });

    it('should show success notification when confirmServiceFlag is true', () => {
      const props = {
        ...defaultProps,
        confirmServiceFlag: true,
        confirmServices: { success: true },
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);
      wrapper.setState({ successMsg: 'Service updated successfully' });

      expect(wrapper.find('Alert').prop('Message')).toBe('Service updated successfully');
      expect(wrapper.find('Alert').prop('Type')).toBe(2);
    });

    it('should show default success message when successMsg is empty', () => {
      const props = {
        ...defaultProps,
        confirmServiceFlag: true,
        confirmServices: null,
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      expect(wrapper.find('Alert').prop('Message')).toBe('Sucessfully blocked');
    });
  });

  describe('Render - Services List', () => {
    it('should render services when getServices is true', () => {
      const props = {
        ...defaultProps,
        getServices: true,
        services: mockServices,
        selectedAccordian: 'BS',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      expect(wrapper.find('.accordion__body').length).toBeGreaterThan(0);
    });

    it('should render service details with Toggle component', () => {
      const props = {
        ...defaultProps,
        getServices: true,
        services: mockServices,
        selectedAccordian: 'BS',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      const toggle = wrapper.find('Toggle').first();
      expect(toggle.exists()).toBe(true);
      expect(toggle.prop('on')).toBe(true);
    });

    it('should render service with showMore expanded', () => {
      const servicesWithShowMore = {
        'Test Services': [
          {
            ...mockServices['Additional Services'][0],
            showMore: true,
          },
        ],
      };

      const props = {
        ...defaultProps,
        getServices: true,
        services: servicesWithShowMore,
        selectedAccordian: 'BS',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: servicesWithShowMore });

      // Check if long description is rendered
      const longDescElement = wrapper.findWhere(
        (node) =>
          node.type() === 'p' &&
          node.prop('dangerouslySetInnerHTML') &&
          node.prop('dangerouslySetInnerHTML').__html === 'Long desc 1'
      );
      expect(longDescElement.exists()).toBe(true);
    });

    it('should not render BLOCK_EMAIL_DOMAIN service in the main list', () => {
      const servicesWithEmailDomain = {
        'Emails & domains': [mockServices['Additional Services'][0]],
        'Other Services': mockServices['Other Services'],
      };

      const props = {
        ...defaultProps,
        getServices: true,
        services: servicesWithEmailDomain,
        selectedAccordian: 'BS',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: servicesWithEmailDomain });

      // The component should render but the Emails & domains section should be empty
      const emailDomainSection = wrapper.findWhere(
        (node) => node.prop('id') === 'Emails & domains'
      );
      expect(emailDomainSection.exists()).toBe(false);
    });
  });

  describe('Render - Modal', () => {
    it('should render Modal with service details', () => {
      const props = {
        ...defaultProps,
        getServices: true,
        services: mockServices,
        selectedAccordian: 'BS',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      const modal = wrapper.find('Modal').first();
      expect(modal.exists()).toBe(true);
      expect(modal.find('ModalTitle').dive().text()).toContain('Service 1');
    });
  });

  describe('Render - Links Section', () => {
    it('should render links when selectedAccordian is BS and getServices is true', () => {
      const props = {
        ...defaultProps,
        getServices: true,
        services: mockServices,
        selectedAccordian: 'BS',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const links = wrapper.find('TextLink');
      expect(links.length).toBeGreaterThan(0);
    });

    it('should not render links when selectedAccordian is not BS', () => {
      const props = {
        ...defaultProps,
        getServices: true,
        services: mockServices,
        selectedAccordian: 'OTHER',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const linksSection = wrapper.findWhere(
        (node) => node.prop('style') && node.prop('style').marginBottom === 15
      );
      expect(linksSection.exists()).toBe(false);
    });

    it('should handle dcbLink click', () => {
      const props = {
        ...defaultProps,
        getServices: true,
        services: mockServices,
        selectedAccordian: 'BS',
      };

      delete window.location;
      window.location = { href: jest.fn() };

      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const dcbLink = wrapper.findWhere(
        (node) => node.prop('data-track') === 'ViewMediaAppPurchases'
      );
      expect(dcbLink.exists()).toBe(true);

      const event = { preventDefault: jest.fn() };
      dcbLink.prop('onClick')(event);

      expect(event.preventDefault).toHaveBeenCalled();
    });

    it('should handle videoLink click', () => {
      const props = {
        ...defaultProps,
        getServices: true,
        services: mockServices,
        selectedAccordian: 'BS',
      };

      delete window.location;
      window.location = { href: jest.fn() };

      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const videoLink = wrapper.findWhere(
        (node) => node.prop('data-track') === 'VideoForBlockServices'
      );
      expect(videoLink.exists()).toBe(true);

      const event = { preventDefault: jest.fn() };
      videoLink.prop('onClick')(event);

      expect(event.preventDefault).toHaveBeenCalled();
    });

    it('should handle faqsLink click', () => {
      const props = {
        ...defaultProps,
        getServices: true,
        services: mockServices,
        selectedAccordian: 'BS',
      };

      delete window.location;
      window.location = { href: jest.fn() };

      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const faqsLink = wrapper.findWhere(
        (node) => node.prop('data-track') === 'BlockFAQ'
      );
      expect(faqsLink.exists()).toBe(true);

      const event = { preventDefault: jest.fn() };
      faqsLink.prop('onClick')(event);

      expect(event.preventDefault).toHaveBeenCalled();
    });
  });

  describe('Render - Loader', () => {
    it('should show loader when isFetching is true', () => {
      const props = {
        ...defaultProps,
        isFetching: true,
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const loader = wrapper.find('Loader');
      expect(loader.prop('active')).toBe(true);
    });

    it('should not show loader when isFetching is false', () => {
      const props = {
        ...defaultProps,
        isFetching: false,
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const loader = wrapper.find('Loader');
      expect(loader.prop('active')).toBe(false);
    });
  });

  describe('Render - Accordion States', () => {
    it('should set aria-expanded to true when selectedAccordian is BS', () => {
      const props = {
        ...defaultProps,
        selectedAccordian: 'BS',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const accordion = wrapper.find('.accordion__title').first();
      expect(accordion.prop('aria-expanded')).toBe(true);
    });

    it('should set aria-expanded to false when selectedAccordian is not BS', () => {
      const props = {
        ...defaultProps,
        selectedAccordian: 'OTHER',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      const accordion = wrapper.find('.accordion__title').first();
      expect(accordion.prop('aria-expanded')).toBe(false);
    });

    it('should handle keyboard event on accordion', () => {
      wrapper = shallow(<BlockServices.WrappedComponent {...defaultProps} />);

      const accordion = wrapper.find('.accordion__title').first();
      const event = { preventDefault: jest.fn() };

      accordion.prop('onKeyPress')(event);

      expect(event.preventDefault).toHaveBeenCalled();
    });
  });

  describe('Edge Cases - pageContent', () => {
    it('should handle missing pageContent gracefully', () => {
      const common = require('../../../../../shared/utilities/util').default;
      common.getContentFromSection.mockReturnValue(null);

      const reloadSpy = jest.spyOn(window.location, 'reload').mockImplementation();

      const props = {
        ...defaultProps,
        serviceStatus: {
          body: { sections: [] },
        },
      };

      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      expect(reloadSpy).toHaveBeenCalled();

      reloadSpy.mockRestore();
    });

    it('should handle missing serviceStatus', () => {
      const props = {
        ...defaultProps,
        serviceStatus: null,
      };

      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      expect(wrapper.exists()).toBe(true);
    });
  });

  describe('Redux Connection', () => {
    it('should map state to props correctly', () => {
      const ConnectedComponent = BlockServices;
      const wrapper = mount(
        <Provider store={store}>
          <ConnectedComponent {...defaultProps} />
        </Provider>
      );

      expect(wrapper.find('BlockServices').props()).toHaveProperty('services');
      expect(wrapper.find('BlockServices').props()).toHaveProperty('isFetching');
    });
  });

  describe('Toggle statusText', () => {
    it('should return "On" when toggle is on', () => {
      const props = {
        ...defaultProps,
        getServices: true,
        services: mockServices,
        selectedAccordian: 'BS',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      const toggle = wrapper.find('Toggle').first();
      const statusText = toggle.prop('statusText');

      expect(statusText(true)).toBe('On');
    });

    it('should return "Off" when toggle is off', () => {
      const props = {
        ...defaultProps,
        getServices: true,
        services: mockServices,
        selectedAccordian: 'BS',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      const toggle = wrapper.find('Toggle').first();
      const statusText = toggle.prop('statusText');

      expect(statusText(false)).toBe('Off');
    });
  });

  describe('Sub-accordion aria states', () => {
    it('should set aria-expanded correctly for sub-accordions', () => {
      const props = {
        ...defaultProps,
        getServices: true,
        services: mockServices,
        selectedAccordian: 'BS',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      // Expand a sub-accordion
      const event = { preventDefault: jest.fn() };
      wrapper.instance().handleSubServices(event, 'Additional Services');

      wrapper.update();

      const subAccordions = wrapper.find('.accordion__title').filterWhere(
        (node) => node.prop('id') === 'Additional Services'
      );

      expect(subAccordions.first().prop('aria-expanded')).toBe(true);
    });

    it('should handle keyboard event on sub-accordion', () => {
      const props = {
        ...defaultProps,
        getServices: true,
        services: mockServices,
        selectedAccordian: 'BS',
      };
      wrapper = shallow(<BlockServices.WrappedComponent {...props} />);

      wrapper.setProps({ services: mockServices });

      const subAccordion = wrapper.find('.accordion__title').filterWhere(
        (node) => node.prop('id') === 'Additional Services'
      );

      const event = { preventDefault: jest.fn() };
      subAccordion.first().prop('onKeyPress')(event);

      expect(event.preventDefault).toHaveBeenCalled();
    });
  });
});